/**
 * Co-Pilot ROI Service
 * 
 * Calculates and tracks the value generated by AI Co-Pilot recommendations.
 * Provides attribution metrics for executive dashboards.
 * Part of AI Co-Pilot v2.
 */

import { prisma } from '../utils/prisma';
import { Logger } from '../utils/logger';

// =============================================================================
// TYPES
// =============================================================================

export interface ROISummary {
    period: {
        start: Date;
        end: Date;
        days: number;
    };

    // Revenue attribution
    revenue: {
        /** Revenue from campaigns affected by AI recommendations */
        attributedRevenue: number;
        /** Estimated revenue increase due to AI actions */
        estimatedLift: number;
        /** Percentage improvement vs baseline */
        liftPercentage: number;
    };

    // Cost savings
    savings: {
        /** Money saved from paused underperforming campaigns */
        pausedCampaignSavings: number;
        /** Budget reallocated from low to high performers */
        reallocationSavings: number;
        /** Total cost avoided */
        totalSavings: number;
    };

    // Action metrics
    actions: {
        /** Total recommendations generated */
        totalRecommendations: number;
        /** Recommendations executed */
        executed: number;
        /** Recommendations pending user review */
        pendingReview: number;
        /** Recommendations dismissed */
        dismissed: number;
        /** Execution rate percentage */
        executionRate: number;
    };

    // Time value
    timeValue: {
        /** Estimated hours of manual work saved */
        hoursSaved: number;
        /** Dollar value of time saved (at avg agency rate) */
        dollarValue: number;
    };

    // Breakdown by action type
    byActionType: Array<{
        type: string;
        count: number;
        estimatedValue: number;
    }>;

    // Top impactful actions
    topActions: Array<{
        id: string;
        type: string;
        description: string;
        valueGenerated: number;
        executedAt: Date;
    }>;
}

// Average time to perform actions manually (in minutes)
const ACTION_TIME_ESTIMATES: Record<string, number> = {
    budget_increase: 10,
    budget_decrease: 10,
    pause: 5,
    enable: 5,
    add_keyword: 15,
    adjust_bid: 10,
    create_campaign: 60,
    audience_sync: 30,
    ad_copy: 45
};

// Average agency hourly rate for time value calculation
const AGENCY_HOURLY_RATE = 150;

// =============================================================================
// SERVICE
// =============================================================================

export class CoPilotROIService {

    /**
     * Get comprehensive ROI summary for an account
     */
    static async getROISummary(
        accountId: string,
        periodDays: number = 30
    ): Promise<ROISummary> {
        const periodEnd = new Date();
        const periodStart = new Date();
        periodStart.setDate(periodStart.getDate() - periodDays);

        // Get all action logs for the period
        const actionLogs = await prisma.adActionLog.findMany({
            where: {
                accountId,
                createdAt: { gte: periodStart, lte: periodEnd }
            },
            orderBy: { createdAt: 'desc' }
        });

        // Get recommendation logs
        const recommendations = await prisma.recommendationLog.findMany({
            where: {
                accountId,
                createdAt: { gte: periodStart, lte: periodEnd }
            }
        });

        // Calculate action metrics
        const executedActions = actionLogs.filter(a => a.status === 'executed');
        const pendingActions = actionLogs.filter(a => a.status === 'pending');
        const dismissedActions = recommendations.filter(r => r.status === 'dismissed');

        // Calculate savings from paused campaigns
        const pauseActions = executedActions.filter(a => a.actionType === 'pause');
        const pausedSavings = await this.calculatePausedSavings(accountId, pauseActions, periodDays);

        // Calculate budget reallocation value
        const budgetActions = executedActions.filter(a =>
            a.actionType === 'budget_increase' || a.actionType === 'budget_decrease'
        );
        const reallocationValue = await this.calculateReallocationValue(accountId, budgetActions);

        // Calculate time savings
        const timeSaved = this.calculateTimeSaved(executedActions);

        // Calculate revenue attribution
        const revenueAttribution = await this.calculateRevenueAttribution(
            accountId,
            executedActions,
            periodStart,
            periodEnd
        );

        // Group by action type
        const byActionType = this.groupByActionType(executedActions);

        // Get top impactful actions
        const topActions = await this.getTopActions(accountId, executedActions.slice(0, 10));

        return {
            period: {
                start: periodStart,
                end: periodEnd,
                days: periodDays
            },
            revenue: revenueAttribution,
            savings: {
                pausedCampaignSavings: pausedSavings,
                reallocationSavings: reallocationValue,
                totalSavings: pausedSavings + reallocationValue
            },
            actions: {
                totalRecommendations: recommendations.length,
                executed: executedActions.length,
                pendingReview: pendingActions.length,
                dismissed: dismissedActions.length,
                executionRate: recommendations.length > 0
                    ? (executedActions.length / recommendations.length) * 100
                    : 0
            },
            timeValue: timeSaved,
            byActionType,
            topActions
        };
    }

    /**
     * Calculate savings from paused campaigns
     */
    private static async calculatePausedSavings(
        accountId: string,
        pauseActions: any[],
        periodDays: number
    ): Promise<number> {
        let totalSavings = 0;

        for (const action of pauseActions) {
            // Get campaign's daily spend before pause
            const metadata = action.metadata as any;
            if (metadata?.campaignBudget) {
                // Calculate days saved (from pause to now or end of period)
                const pauseDate = new Date(action.executedAt || action.createdAt);
                const now = new Date();
                const daysSaved = Math.min(
                    Math.floor((now.getTime() - pauseDate.getTime()) / (1000 * 60 * 60 * 24)),
                    periodDays
                );

                // Multiply daily budget by days saved
                totalSavings += (metadata.campaignBudget * daysSaved);
            }
        }

        return totalSavings;
    }

    /**
     * Calculate value from budget reallocation
     */
    private static async calculateReallocationValue(
        accountId: string,
        budgetActions: any[]
    ): Promise<number> {
        let totalValue = 0;

        // Budget increases on high-performers generate value
        for (const action of budgetActions) {
            if (action.actionType === 'budget_increase') {
                const metadata = action.metadata as any;
                if (metadata?.amount && metadata?.campaignRoas) {
                    // Value = (budget increase * ROAS improvement opportunity)
                    // Estimate 10% ROAS improvement from optimized allocation
                    const potentialRevenue = metadata.amount * (metadata.campaignRoas + 0.1);
                    const baselineRevenue = metadata.amount * metadata.campaignRoas;
                    totalValue += (potentialRevenue - baselineRevenue);
                }
            }
        }

        return Math.max(0, totalValue);
    }

    /**
     * Calculate time saved by automated actions
     */
    private static calculateTimeSaved(executedActions: any[]): {
        hoursSaved: number;
        dollarValue: number;
    } {
        let totalMinutes = 0;

        for (const action of executedActions) {
            const timeEstimate = ACTION_TIME_ESTIMATES[action.actionType] || 10;
            totalMinutes += timeEstimate;
        }

        const hoursSaved = totalMinutes / 60;
        const dollarValue = hoursSaved * AGENCY_HOURLY_RATE;

        return { hoursSaved, dollarValue };
    }

    /**
     * Calculate revenue attribution from AI actions
     */
    private static async calculateRevenueAttribution(
        accountId: string,
        executedActions: any[],
        periodStart: Date,
        periodEnd: Date
    ): Promise<{
        attributedRevenue: number;
        estimatedLift: number;
        liftPercentage: number;
    }> {
        // Get outcome data from recommendation logs
        const outcomes = await prisma.recommendationLog.findMany({
            where: {
                accountId,
                status: 'implemented',
                outcomeRecordedAt: { not: null },
                implementedAt: { gte: periodStart, lte: periodEnd }
            },
            select: {
                id: true,
                roasBefore: true,
                roasAfter: true,
                dataPoints: true
            }
        });

        let totalLift = 0;
        let baselineRevenue = 0;

        for (const outcome of outcomes) {
            if (outcome.roasBefore && outcome.roasAfter) {
                const improvement = outcome.roasAfter - outcome.roasBefore;
                if (improvement > 0) {
                    // Estimate revenue lift based on ROAS improvement
                    // Assuming average campaign spend context
                    totalLift += improvement * 100; // Simplified calculation
                }
            }
        }


        // Get total ad revenue for the period
        const { AdsService } = await import('./ads');
        const adAccounts = await AdsService.getAdAccounts(accountId);

        let totalAdRevenue = 0;
        for (const adAccount of adAccounts) {
            try {
                if (adAccount.platform === 'GOOGLE') {
                    const insights = await AdsService.getGoogleInsights(adAccount.id) as any;
                    totalAdRevenue += insights?.conversionsValue || 0;
                } else if (adAccount.platform === 'META') {
                    const insights = await AdsService.getMetaInsights(adAccount.id) as any;
                    totalAdRevenue += insights?.purchase_roas?.reduce((sum: number, r: any) => sum + (r.value || 0), 0) || 0;
                }
            } catch {
                // Skip on error
            }
        }

        // Attribute a portion of revenue to AI actions
        // Conservative estimate: 5% of revenue attributable to AI optimization
        const attributionRate = 0.05;
        const attributedRevenue = totalAdRevenue * attributionRate;

        return {
            attributedRevenue,
            estimatedLift: totalLift,
            liftPercentage: totalAdRevenue > 0 ? (attributedRevenue / totalAdRevenue) * 100 : 0
        };
    }

    /**
     * Group actions by type with value estimates
     */
    private static groupByActionType(executedActions: any[]): Array<{
        type: string;
        count: number;
        estimatedValue: number;
    }> {
        const groups = new Map<string, { count: number; value: number }>();

        for (const action of executedActions) {
            const existing = groups.get(action.actionType) || { count: 0, value: 0 };
            const timeValue = (ACTION_TIME_ESTIMATES[action.actionType] || 10) / 60 * AGENCY_HOURLY_RATE;

            groups.set(action.actionType, {
                count: existing.count + 1,
                value: existing.value + timeValue
            });
        }

        return Array.from(groups.entries()).map(([type, data]) => ({
            type,
            count: data.count,
            estimatedValue: data.value
        })).sort((a, b) => b.estimatedValue - a.estimatedValue);
    }

    /**
     * Get top impactful actions
     */
    private static async getTopActions(
        accountId: string,
        recentActions: any[]
    ): Promise<Array<{
        id: string;
        type: string;
        description: string;
        valueGenerated: number;
        executedAt: Date;
    }>> {
        return recentActions.map(action => {
            const metadata = action.metadata as any;
            const timeValue = (ACTION_TIME_ESTIMATES[action.actionType] || 10) / 60 * AGENCY_HOURLY_RATE;

            let description = '';
            switch (action.actionType) {
                case 'pause':
                    description = `Paused underperforming campaign: ${metadata?.campaignName || 'Unknown'}`;
                    break;
                case 'enable':
                    description = `Enabled campaign: ${metadata?.campaignName || 'Unknown'}`;
                    break;
                case 'budget_increase':
                    description = `Increased budget by $${metadata?.amount || 0} for ${metadata?.campaignName || 'campaign'}`;
                    break;
                case 'budget_decrease':
                    description = `Decreased budget by $${metadata?.amount || 0} for ${metadata?.campaignName || 'campaign'}`;
                    break;
                case 'add_keyword':
                    description = `Added keyword: ${metadata?.keyword || 'Unknown'}`;
                    break;
                default:
                    description = `${action.actionType} action on ${metadata?.campaignName || 'campaign'}`;
            }

            return {
                id: action.id,
                type: action.actionType,
                description,
                valueGenerated: timeValue + (metadata?.estimatedValue || 0),
                executedAt: action.executedAt || action.createdAt
            };
        });
    }

    /**
     * Get quick stats for dashboard widget
     */
    static async getQuickStats(accountId: string): Promise<{
        totalValue: number;
        actionsExecuted: number;
        hoursSaved: number;
        pendingActions: number;
    }> {
        const summary = await this.getROISummary(accountId, 30);

        return {
            totalValue: summary.savings.totalSavings + summary.timeValue.dollarValue,
            actionsExecuted: summary.actions.executed,
            hoursSaved: Math.round(summary.timeValue.hoursSaved * 10) / 10,
            pendingActions: summary.actions.pendingReview
        };
    }
}

export default CoPilotROIService;
